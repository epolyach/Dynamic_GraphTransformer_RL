#!/usr/bin/env python3
import time
from typing import Dict, Any, List, Tuple
import numpy as np
from solvers.types import CVRPSolution
from solvers.utils import calculate_route_cost


def solve(instance: Dict[str, Any], time_limit: float = 60.0, verbose: bool = False) -> CVRPSolution:
    """Heuristic OR-Tools VRP solver wrapper (not exact).
    Returns is_optimal=False.
    """
    try:
        from ortools.constraint_solver import pywrapcp
        from ortools.constraint_solver import routing_enums_pb2
    except Exception as e:
        raise ImportError(f"OR-Tools constraint solver not available: {e}")

    start_time = time.time()
    coords = instance['coords']
    demands = instance['demands']
    distances = instance['distances']
    capacity = int(instance['capacity'])
    n_customers = len(coords) - 1

    total_demand = int(sum(int(d) for d in demands[1:]))
    min_vehicles = max(1, int(np.ceil(total_demand / capacity)))
    max_vehicles = min(n_customers, min_vehicles + 2)

    best_route: List[int] = [0]
    best_vehicle_routes: List[List[int]] = []
    best_cost = float('inf')

    for n_vehicles in range(min_vehicles, max_vehicles + 1):
        manager = pywrapcp.RoutingIndexManager(len(coords), n_vehicles, 0)
        routing = pywrapcp.RoutingModel(manager)

        def distance_callback(from_index, to_index):
            i = manager.IndexToNode(from_index)
            j = manager.IndexToNode(to_index)
            return int(distances[i][j] * 1000)

        transit_idx = routing.RegisterTransitCallback(distance_callback)
        routing.SetArcCostEvaluatorOfAllVehicles(transit_idx)

        def demand_callback(from_index):
            i = manager.IndexToNode(from_index)
            return int(demands[i])

        demand_idx = routing.RegisterUnaryTransitCallback(demand_callback)
        routing.AddDimensionWithVehicleCapacity(demand_idx, 0, [capacity] * n_vehicles, True, 'Capacity')

        search_parameters = pywrapcp.DefaultRoutingSearchParameters()
        search_parameters.first_solution_strategy = routing_enums_pb2.FirstSolutionStrategy.BEST_INSERTION
        search_parameters.local_search_metaheuristic = routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH
        search_parameters.time_limit.seconds = int(max(1, time_limit / (max_vehicles - min_vehicles + 1)))
        search_parameters.log_search = False

        solution = routing.SolveWithParameters(search_parameters)
        if solution:
            obj = solution.ObjectiveValue() / 1000.0
            if obj < best_cost:
                best_cost = obj
                route = [0]
                vrs: List[List[int]] = []
                for vid in range(routing.vehicles()):
                    index = routing.Start(vid)
                    vr = [0]
                    while not routing.IsEnd(index):
                        node = manager.IndexToNode(index)
                        if node != 0:
                            vr.append(node)
                        index = solution.Value(routing.NextVar(index))
                    if len(vr) > 1:
                        vr.append(0)
                        vrs.append(vr[1:-1])
                        route.extend(vr[1:-1])
                best_route = route
                best_vehicle_routes = vrs

        if time.time() - start_time > time_limit:
            break

    if best_cost == float('inf'):
        raise RuntimeError("Heuristic OR-Tools solver failed to find any feasible solution")

    # Use standardized cost calculation for consistency across all solvers
    standardized_cost = calculate_route_cost(best_vehicle_routes, distances)

    return CVRPSolution(route=best_route, cost=standardized_cost, num_vehicles=len(best_vehicle_routes),
                        vehicle_routes=best_vehicle_routes, solve_time=time.time() - start_time,
                        algorithm_used='Heuristic-OR', is_optimal=False)

