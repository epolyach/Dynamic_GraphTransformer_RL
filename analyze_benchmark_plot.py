#!/usr/bin/env python3
"""Analyze why non-optimal solvers fail before N=20"""

print("="*70)
print("ANALYSIS: Why solvers get disabled before N=20")
print("="*70)

print("\nðŸ“Š FROM THE CODE ANALYSIS:")
print("-" * 40)

print("\n1. HARDCODED LIMIT FOR exact_dp:")
print("   â€¢ exact_dp is EXPLICITLY disabled for N>10")
print("   â€¢ Code: 'if solver_name == \"exact_dp\" and n > 10: SKIPPED'")
print("   â€¢ Reason: Brute force DP has O(2^n * n^2) complexity")
print("   â€¢ This is intentional - not a failure!")

print("\n2. TIMEOUT MECHANISM FOR OTHER SOLVERS:")
print("   â€¢ Default timeout: 60 seconds total per N")
print("   â€¢ Per-instance timeout: 60s / min_instances (e.g., 60/5 = 12s per instance)")
print("   â€¢ If a solver hits timeout on 3 consecutive instances â†’ DISABLED")
print("   â€¢ MAX_CONSECUTIVE_FAILURES = 3")

print("\n3. WHY exact_ortools_vrp GETS DISABLED:")
print("   â€¢ For Nâ‰¥7, instances become hard")
print("   â€¢ Exact branch-and-bound needs exponential time")
print("   â€¢ Hits 12s timeout per instance")
print("   â€¢ After 3 timeouts â†’ disabled")

print("\nðŸ“ˆ COMPLEXITY GROWTH:")
print("-" * 40)
print("Problem size | Search space | Approx time for exact")
print("-------------|--------------|----------------------")
print("N=5          | ~10^3        | <1 second")
print("N=7          | ~10^5        | 1-10 seconds")
print("N=10         | ~10^8        | 10-100 seconds")
print("N=15         | ~10^13       | hours/days")
print("N=20         | ~10^18       | years")

print("\nðŸ” WHAT THE PLOT SHOWS:")
print("-" * 40)
print("1. exact_dp (blue): Stops at N=10 (hardcoded limit)")
print("2. exact_ortools_vrp (orange): Stops around N=7-8 (timeout)")
print("3. heuristic_or (green): Continues to N=15+ (fast enough)")

print("\nâš™ï¸ TIMEOUT CALCULATION:")
print("-" * 40)
print("With default settings:")
print("â€¢ Total timeout per N: 60 seconds")
print("â€¢ Min instances: 5")
print("â€¢ Per-instance timeout: 60/5 = 12 seconds")
print("â€¢ 3 consecutive timeouts â†’ solver disabled")
print()
print("For N=7:")
print("â€¢ exact_ortools_vrp might take 5-30s per instance")
print("â€¢ Some instances exceed 12s â†’ timeout")
print("â€¢ After 3 timeouts â†’ DISABLED")

print("\nðŸ’¡ CONCLUSION:")
print("-" * 40)
print("The code is NOT broken or old. It's working as designed:")
print()
print("1. exact_dp intentionally limited to Nâ‰¤10 (complexity)")
print("2. exact_ortools_vrp times out around N=7-8 (NP-hard)")
print("3. Only heuristic_or survives to larger N (polynomial time)")
print()
print("This is EXPECTED behavior for NP-hard problems!")
print("Exact methods hit computational walls quickly.")

print("\nðŸŽ¯ TO RUN LARGER N WITH EXACT SOLVERS:")
print("-" * 40)
print("You would need to:")
print("1. Increase timeout: --timeout 300 (5 minutes)")
print("2. Reduce instances: --instances-min 1")
print("3. But even then, N>15 is intractable for exact methods")
print()
print("That's why you're using heuristics for N=20!")
