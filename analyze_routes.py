#!/usr/bin/env python3
"""
Analyze the routes generated by different models to understand why 
Baseline Pointer performs worse than naive baseline.
"""

import torch
import numpy as np
import matplotlib.pyplot as plt
from run_comparative_study import (
    generate_cvrp_instance, 
    BaselinePointerNetwork,
    compute_route_cost,
    compute_naive_baseline_cost
)

def visualize_routes_comparison(instance, routes_dict, costs_dict):
    """Visualize routes from different approaches"""
    coords = instance['coords']
    demands = instance['demands']
    
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    
    # Colors for different routes
    colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown']
    
    approaches = ['Naive', 'Baseline Pointer', 'Graph Transformer', 'Dynamic Graph Transformer']
    
    for idx, (approach, route) in enumerate(routes_dict.items()):
        ax = axes[idx//2, idx%2]
        
        # Plot all nodes
        ax.scatter(coords[0, 0], coords[0, 1], c='black', s=200, marker='s', label='Depot')
        for i in range(1, len(coords)):
            ax.scatter(coords[i, 0], coords[i, 1], c='lightblue', s=100, marker='o')
            ax.annotate(f'{i}\n(d={demands[i]:.0f})', (coords[i, 0], coords[i, 1]), 
                       xytext=(5, 5), textcoords='offset points', fontsize=8)
        
        # Plot route
        if approach == 'Naive':
            # Naive: depot -> customer -> depot for each customer
            for i in range(1, len(coords)):
                ax.plot([coords[0, 0], coords[i, 0]], [coords[0, 1], coords[i, 1]], 
                       'r--', alpha=0.6, linewidth=1)
                ax.plot([coords[i, 0], coords[0, 0]], [coords[i, 1], coords[0, 1]], 
                       'r--', alpha=0.6, linewidth=1)
        else:
            # Plot actual route
            route_coords = coords[route]
            ax.plot(route_coords[:, 0], route_coords[:, 1], 'g-', linewidth=2, alpha=0.8)
            
            # Add arrows to show direction
            for i in range(len(route_coords)-1):
                dx = route_coords[i+1, 0] - route_coords[i, 0]
                dy = route_coords[i+1, 1] - route_coords[i, 1]
                ax.arrow(route_coords[i, 0], route_coords[i, 1], dx*0.8, dy*0.8,
                        head_width=1.5, head_length=1.0, fc='green', ec='green', alpha=0.7)
        
        ax.set_title(f'{approach}\nCost: {costs_dict[approach]:.1f}', fontweight='bold')
        ax.set_xlabel('X coordinate')
        ax.set_ylabel('Y coordinate')
        ax.grid(True, alpha=0.3)
        ax.legend()
    
    plt.tight_layout()
    plt.savefig('route_comparison.png', dpi=300, bbox_inches='tight')
    plt.show()
    print("🗺️ Route comparison saved to route_comparison.png")

def analyze_route_efficiency(route, instance):
    """Analyze route efficiency metrics"""
    coords = instance['coords']
    distances = instance['distances']
    demands = instance['demands']
    
    # Basic metrics
    total_distance = compute_route_cost(route, distances)
    num_depot_visits = route.count(0)
    customers_visited = len(set(route) - {0})
    
    # Route segments (between depot visits)
    segments = []
    current_segment = []
    
    for node in route:
        if node == 0:
            if current_segment:
                segments.append(current_segment)
                current_segment = []
        else:
            current_segment.append(node)
    
    # Segment analysis
    segment_costs = []
    segment_demands = []
    
    for segment in segments:
        if segment:
            # Cost of this segment: depot -> customers -> depot
            segment_route = [0] + segment + [0]
            segment_cost = compute_route_cost(segment_route, distances)
            segment_demand = sum(demands[customer] for customer in segment)
            
            segment_costs.append(segment_cost)
            segment_demands.append(segment_demand)
    
    return {
        'total_cost': total_distance,
        'depot_visits': num_depot_visits,
        'customers_visited': customers_visited,
        'num_segments': len(segments),
        'segments': segments,
        'segment_costs': segment_costs,
        'segment_demands': segment_demands,
        'avg_segment_cost': np.mean(segment_costs) if segment_costs else 0,
        'route_efficiency': customers_visited / num_depot_visits if num_depot_visits > 0 else 0
    }

def main():
    print("🔍 Analyzing why Baseline Pointer performs worse than naive baseline...")
    
    # Generate a test instance
    torch.manual_seed(42)
    np.random.seed(42)
    
    instance = generate_cvrp_instance(
        num_customers=15, 
        capacity=3, 
        coord_range=50, 
        demand_range=(1, 3), 
        seed=42
    )
    
    print(f"📍 Test instance: {len(instance['coords'])-1} customers, capacity={instance['capacity']}")
    
    # Load trained models
    baseline_model = BaselinePointerNetwork(3, 64)
    baseline_checkpoint = torch.load('model_baseline_pointer.pt', weights_only=False)
    baseline_model.load_state_dict(baseline_checkpoint['model_state_dict'])
    baseline_model.eval()
    
    # Generate routes
    print("\n🚀 Generating routes...")
    
    routes_dict = {}
    costs_dict = {}
    
    # Naive baseline route (separate trip for each customer)
    naive_cost = compute_naive_baseline_cost(instance)
    naive_route = []
    for i in range(1, len(instance['coords'])):
        naive_route.extend([0, i, 0])  # depot -> customer -> depot
    
    routes_dict['Naive'] = naive_route
    costs_dict['Naive'] = naive_cost
    
    # Baseline Pointer route
    with torch.no_grad():
        baseline_routes, _ = baseline_model([instance], greedy=True)
        baseline_route = baseline_routes[0]
        baseline_cost = compute_route_cost(baseline_route, instance['distances'])
    
    routes_dict['Baseline Pointer'] = baseline_route
    costs_dict['Baseline Pointer'] = baseline_cost
    
    # Load and test other models
    try:
        from run_comparative_study import GraphTransformerNetwork, DynamicGraphTransformerNetwork
        
        # Graph Transformer
        gt_model = GraphTransformerNetwork(3, 64, 4, 2)
        gt_checkpoint = torch.load('model_graph_transformer.pt', weights_only=False)
        gt_model.load_state_dict(gt_checkpoint['model_state_dict'])
        gt_model.eval()
        
        with torch.no_grad():
            gt_routes, _ = gt_model([instance], greedy=True)
            gt_route = gt_routes[0]
            gt_cost = compute_route_cost(gt_route, instance['distances'])
        
        routes_dict['Graph Transformer'] = gt_route
        costs_dict['Graph Transformer'] = gt_cost
        
        # Dynamic Graph Transformer
        dgt_model = DynamicGraphTransformerNetwork(3, 64, 4, 2)
        dgt_checkpoint = torch.load('model_dynamic_graph_transformer.pt', weights_only=False)
        dgt_model.load_state_dict(dgt_checkpoint['model_state_dict'])
        dgt_model.eval()
        
        with torch.no_grad():
            dgt_routes, _ = dgt_model([instance], greedy=True)
            dgt_route = dgt_routes[0]
            dgt_cost = compute_route_cost(dgt_route, instance['distances'])
        
        routes_dict['Dynamic Graph Transformer'] = dgt_route
        costs_dict['Dynamic Graph Transformer'] = dgt_cost
        
    except Exception as e:
        print(f"⚠️ Could not load transformer models: {e}")
        routes_dict['Graph Transformer'] = [0, 1, 2, 3, 0]  # Dummy
        costs_dict['Graph Transformer'] = 0
        routes_dict['Dynamic Graph Transformer'] = [0, 1, 2, 3, 0]  # Dummy  
        costs_dict['Dynamic Graph Transformer'] = 0
    
    # Print cost comparison
    print("\n💰 COST COMPARISON:")
    print("=" * 40)
    for approach, cost in costs_dict.items():
        print(f"{approach:25}: {cost:.2f}")
    
    # Analyze baseline pointer route in detail
    print("\n🔍 DETAILED ROUTE ANALYSIS:")
    print("=" * 40)
    
    for approach in ['Naive', 'Baseline Pointer']:
        print(f"\n{approach}:")
        route = routes_dict[approach]
        print(f"  Route: {route}")
        
        if approach != 'Naive':
            analysis = analyze_route_efficiency(route, instance)
            print(f"  Total cost: {analysis['total_cost']:.2f}")
            print(f"  Depot visits: {analysis['depot_visits']}")
            print(f"  Route segments: {analysis['num_segments']}")
            print(f"  Segments: {analysis['segments']}")
            print(f"  Segment costs: {[f'{c:.1f}' for c in analysis['segment_costs']]}")
            print(f"  Segment demands: {analysis['segment_demands']}")
            print(f"  Route efficiency: {analysis['route_efficiency']:.2f} customers/depot_visit")
    
    # Visualize routes
    visualize_routes_comparison(instance, routes_dict, costs_dict)
    
    print(f"\n📊 CONCLUSION:")
    print(f"Baseline Pointer cost: {costs_dict['Baseline Pointer']:.2f}")
    print(f"Naive baseline cost: {costs_dict['Naive']:.2f}")
    difference = costs_dict['Baseline Pointer'] - costs_dict['Naive']
    print(f"Difference: {difference:.2f} ({'worse' if difference > 0 else 'better'})")
    
    if difference > 0:
        print("\n💡 POSSIBLE REASONS:")
        print("1. The model hasn't fully learned optimal routing patterns")
        print("2. Simple attention mechanism struggles with spatial optimization")
        print("3. Training exploration may have led to suboptimal learned policies")
        print("4. The model attempts complex multi-customer routes but executes them poorly")

if __name__ == "__main__":
    main()
